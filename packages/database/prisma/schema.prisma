generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User account with linked services
//
// NOTE: The User model requires a CHECK constraint to ensure at least one identity
// field (discordId, startggId, or email) is not null. Prisma does not support
// CHECK constraints natively, so this must be implemented via a raw SQL migration.
//
// Required migration (run manually or via prisma migrate):
//   ALTER TABLE "User" ADD CONSTRAINT "User_has_identity"
//   CHECK ("discordId" IS NOT NULL OR "startggId" IS NOT NULL OR "email" IS NOT NULL);
model User {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Discord identity
  discordId       String?   @unique
  discordUsername String?
  discordAvatar   String?

  // Start.gg identity
  startggId       String?   @unique
  startggSlug     String?
  startggGamerTag String?
  startggToken    String?   // Encrypted OAuth token

  // Local identity (for users without Start.gg)
  email           String?   @unique
  displayName     String?

  // Relations
  registrations   Registration[]
  matchPlayers    MatchPlayer[]
  adminTournaments TournamentAdmin[]
  initiatedDisputes Dispute[] @relation("DisputeInitiator")
  resolvedDisputes Dispute[] @relation("DisputeResolver")
  auditLogs      AuditLog[]

  @@index([discordId])
  @@index([startggId])
  @@index([startggGamerTag])
}

// Tournament configuration
model Tournament {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Start.gg reference
  startggId       String    @unique
  startggSlug     String

  // Tournament info (cached from Start.gg)
  name            String
  startAt         DateTime?
  endAt           DateTime?
  state           TournamentState @default(CREATED)

  // Discord configuration
  discordGuildId  String?
  discordChannelId String?  // Main announcement channel

  // Settings
  autoCreateThreads    Boolean @default(true)
  requireCheckIn       Boolean @default(true)
  checkInWindowMinutes Int     @default(10)
  allowSelfReporting   Boolean @default(true)

  // Relations
  events          Event[]
  registrations   Registration[]
  admins          TournamentAdmin[]

  // Polling state
  lastPolledAt    DateTime?
  pollIntervalMs  Int       @default(30000)

  @@index([startggSlug])
  @@index([discordGuildId])
}

enum TournamentState {
  CREATED
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Tournament events (e.g., different games/brackets)
model Event {
  id              String    @id @default(cuid())

  // Start.gg reference
  startggId       String    @unique

  // Event info
  name            String
  numEntrants     Int       @default(0)
  state           Int       @default(1)

  // Relations
  tournamentId    String
  tournament      Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  matches         Match[]
  registrations   Registration[]

  @@index([tournamentId])
}

// Individual matches
model Match {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Start.gg reference
  startggSetId    String    @unique

  // Match info
  identifier      String    // e.g., "A1", "B3"
  roundText       String    // e.g., "Winners Round 1"
  round           Int
  state           MatchState @default(NOT_STARTED)

  // Discord thread
  discordThreadId String?   @unique
  discordMessageId String?  // ID of the embed message for updates

  // Check-in tracking
  checkInDeadline DateTime?

  // Start.gg sync tracking
  startggSyncStatus StartggSyncStatus @default(NOT_SYNCED)
  startggSyncError  String?           // Error message if sync failed

  // Relations
  eventId         String
  event           Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  players         MatchPlayer[]
  disputes        Dispute[]
  games           GameResult[]

  @@index([eventId])
  @@index([state])
  @@index([discordThreadId])
  @@index([startggSyncStatus])
  @@index([eventId, state])
}

enum MatchState {
  NOT_STARTED
  CALLED          // Players notified
  CHECKED_IN      // Both players checked in
  IN_PROGRESS
  PENDING_CONFIRMATION // Score reported, awaiting confirm
  COMPLETED
  DISPUTED
  DQ              // Disqualification
}

enum StartggSyncStatus {
  NOT_SYNCED      // Not yet synced (default)
  PENDING         // Sync in progress
  SYNCED          // Successfully synced
  FAILED          // Sync failed, needs retry
}

// Match participants
model MatchPlayer {
  id              String    @id @default(cuid())

  // Player info
  startggEntrantId String?
  playerName      String    // Cached name

  // Status
  isCheckedIn     Boolean   @default(false)
  checkedInAt     DateTime?
  reportedScore   Int?
  isWinner        Boolean?

  // Relations
  matchId         String
  match           Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  userId          String?
  user            User?     @relation(fields: [userId], references: [id])

  @@unique([matchId, startggEntrantId])
  @@index([userId])
  @@index([matchId])

  // Detailed game results
  games GameResult[]
}

// Individual game results for detailed score reporting
model GameResult {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())

  matchId       String
  matchPlayerId String
  gameNumber    Int       // 1, 2, 3, etc.

  // Game winner (one of the two players in the match)
  winnerId      String?   // MatchPlayer ID who won this game

  // Optional game details
  characterId   String?
  characterName String?
  stageId       String?
  stageName     String?

  // Relations
  match         Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchPlayer   MatchPlayer @relation(fields: [matchPlayerId], references: [id])

  @@unique([matchPlayerId, gameNumber])
  @@index([matchId])
}

// Match disputes
model Dispute {
  id            String        @id @default(cuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Match reference
  matchId       String
  match         Match         @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // Who initiated the dispute
  initiatorId   String
  initiator     User          @relation("DisputeInitiator", fields: [initiatorId], references: [id])

  // Dispute details
  reason        String?

  // Resolution
  status        DisputeStatus @default(OPEN)
  resolvedById  String?
  resolvedBy    User?         @relation("DisputeResolver", fields: [resolvedById], references: [id])
  resolution    String?
  resolvedAt    DateTime?

  @@index([matchId])
  @@index([initiatorId])
  @@index([status])
}

enum DisputeStatus {
  OPEN
  RESOLVED
  CANCELLED
}

// Tournament registrations
model Registration {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())

  // Start.gg reference
  startggEntrantId String?  @map("startgg_entrant_id")

  // Registration source
  source          RegistrationSource @default(DISCORD)

  // Status
  status          RegistrationStatus @default(PENDING)

  // For manual registrations without Start.gg
  displayName     String?

  // Relations
  userId          String?   @map("user_id")  // Nullable for ghost registrations (Start.gg only)
  user            User?     @relation(fields: [userId], references: [id])
  tournamentId    String    @map("tournament_id")
  tournament      Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  eventId         String?   @map("event_id")  // Nullable for backwards compatibility
  event           Event?    @relation(fields: [eventId], references: [id])

  // Note: Unique constraint on (eventId, startggEntrantId) is NOT added to the database schema
  // because existing production data may contain duplicates from before this was enforced.
  // Adding a unique constraint would require a data migration to clean duplicates.
  //
  // For ghost registrations (Start.gg entrants without linked Discord users), we need a partial
  // unique index on (eventId, startggEntrantId) WHERE startggEntrantId IS NOT NULL.
  // PostgreSQL treats NULLs as distinct, so a standard unique constraint would allow multiple
  // NULL values. Since Prisma doesn't support partial indexes natively, this requires a raw SQL
  // migration (see migrations/ folder).
  //
  // Application-level enforcement is implemented as follows:
  // 1. RegistrationSyncService uses a transaction with atomic operations to prevent race conditions
  // 2. The /register and /admin register commands check for existing registrations before creating
  // 3. The unique constraint on (userId, eventId) provides some protection for Discord-based registrations
  //
  // TODO: Add partial unique index via raw SQL migration after cleaning duplicate data in production:
  // CREATE UNIQUE INDEX "registration_event_entrant_unique" ON "Registration"
  // ("eventId", "startggEntrantId") WHERE "startggEntrantId" IS NOT NULL;
  @@unique([userId, eventId])
  @@index([tournamentId])
  @@index([eventId])
}

enum RegistrationSource {
  STARTGG         // Registered via Start.gg
  DISCORD         // Registered via Discord bot
  MANUAL          // Admin added manually
}

enum RegistrationStatus {
  PENDING         // Awaiting approval or Start.gg sync
  CONFIRMED       // Confirmed in Start.gg
  CANCELLED
  DQ
}

// Tournament administrators
model TournamentAdmin {
  id              String    @id @default(cuid())

  role            AdminRole @default(MODERATOR)

  userId          String
  user            User      @relation(fields: [userId], references: [id])
  tournamentId    String
  tournament      Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([userId, tournamentId])
}

enum AdminRole {
  OWNER
  ADMIN
  MODERATOR
}

// Discord guild configuration
model GuildConfig {
  id              String    @id @default(cuid())

  discordGuildId  String    @unique

  // Default channels
  announcementChannelId String?
  matchChannelId  String?   // Where match threads are created

  // Settings
  prefix          String    @default("!")
  locale          String    @default("en")
  timezone        String    @default("UTC")

  @@index([discordGuildId])
}

// Audit logging for administrative actions
model AuditLog {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())

  // Action type
  action      AuditAction

  // Entity being acted upon
  entityType  String    // e.g., "Match", "Registration", "Tournament"
  entityId    String

  // Who performed the action
  userId      String
  user        User      @relation(fields: [userId], references: [id])

  // Before/after state
  before      Json?     // Previous state
  after       Json?     // New state

  // Optional reason provided by admin
  reason      String?

  // Source of the action (Discord command, web admin, API)
  source      AuditSource @default(DISCORD)

  @@index([entityType, entityId])
  @@index([userId])
  @@index([createdAt])
  @@index([action])
}

enum AuditAction {
  // Tournament actions
  TOURNAMENT_CREATED
  TOURNAMENT_UPDATED
  TOURNAMENT_DELETED

  // Match actions
  MATCH_SCORE_OVERRIDE
  MATCH_RESET
  MATCH_REOPEN

  // Player actions
  PLAYER_DQ
  PLAYER_UNDQ
  PLAYER_CHECK_IN
  PLAYER_CHECK_OUT

  // Registration actions
  REGISTRATION_APPROVED
  REGISTRATION_REJECTED
  REGISTRATION_MANUAL_ADD
  REGISTRATION_MANUAL_REMOVE

  // Dispute actions
  DISPUTE_OPENED
  DISPUTE_RESOLVED
  DISPUTE_CANCELLED

  // Configuration actions
  CONFIG_UPDATED

  // Admin actions
  ADMIN_ADDED
  ADMIN_REMOVED
}

enum AuditSource {
  DISCORD
  WEB
  API
}
